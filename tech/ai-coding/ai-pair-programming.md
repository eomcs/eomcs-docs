# 1. AI 페어 프로그래밍(AI Pair Programming)

AI 코딩은 **인공지능(AI)을 활용해 소프트웨어 코드를 작성·보조·자동화하는 방식**을 의미한다. 단순히 "AI가 코드를 대신 짜준다"는 차원을 넘어, 개발자의 생산성을 높이고 협업 방식을 바꾸는 포괄적인 개념이다.

## 1.1 정의

AI 코딩(AI-assisted coding, AI programming)은 **대규모 언어모델(LLM)**, **코드 특화 모델(예: Codex, Code Llama, Gemini Code)**, 또는 **에이전트 기반 AI**를 이용하여 코드 생성·보완·리팩터링·문서화 등 개발 과정을 자동화하는 기법입니다. 핵심은 AI가 단순 자동 완성 수준을 넘어, 맥락을 이해하고 개발 전 과정에 개입한다는 점이다.

## 1.2 주요 방식

### 1.2.1 코드 자동완성 (Predictive Autocompletion)
- 개발자가 코드 일부를 타이핑하면, 다음 토큰·한 줄·짧은 블록을 예측해 제안
- 함수의 이름과 시그니처를 보고 내부 구현을 예측
- 장점: 반복 코드 작성 속도 증가, 문법 실수 감소
- 한계: 복잡한 로직보다는 짧은 코드 제안에 적합
- 도구: GitHub Copilot, IntelliJ AI Assistant

#### 실습 | 링크드 리스트 자료구조 구현하기
- 메인 클래스(App.java) 만들기
    ```
    1. app01 폴더를 생성한다.
    2. App.java 파일을 생성한다.
    3. 클래스를 정의하는 코드 일부를 작성한다.
    4. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    ```
- 링크드 리스트 자료구조를 구현한 클래스(LinkedList.java) 만들기
    ```
    1. LinkedList.java 파일을 생성한다.
    2. 클래스를 정의하는 코드 일부를 작성한다.
    3. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    4. 필드를 정의하는 코드 일부를 작성한다.
    5. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    6. add() 메서드를 정의하는 코드 일부를 작성한다.
    7. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    8. get() 메서드를 정의하는 코드 일부를 작성한다.
    9. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    10. size() 메서드를 정의하는 코드 일부를 작성한다.
    11. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    ```
- 메인 클래스에서 링크드 리스트 사용하기
    ``` 
    1. App.main() 메서드에 LinkedList 인스턴스 생성 코드 일부를 작성한다.
    2. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    3. 목록에 들어 있는 값을 조회하는 반복문 코드 일부를 작성한다.
    4. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    ```
- 값 삽입 메서드 추가
    ```
    1. LinkedList에 add(int index, int value) 메서드를 정의하는 코드 일부를 작성한다.
    2. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    3. App.main() 메서드에 add(int index, int value) 메서드를 호출하는 코드 일부를 작성한다.
    4. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    5. 실행한 후, 오류 내용을 교정한다. 
        - 맨 앞에 삽입, 중간에 삽입, 맨 뒤에 삽입을 테스트한다.
    ```
- 인덱스 오류 기능 테스트 및 예외 처리
    ```
    1. App.main() 메서드에 무효한 인덱스 값으로 add() 메서드를 호출하는 코드 일부를 작성한다.
    2. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    3. 실행하여 오류 내용을 확인한 후 add(int index, int value) 메서드를 수정한다.
    4. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    5. get() 메서드도 수정한다.
    6. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    ```
- 값 삭제 메서드 추가
    ```
    1. LinkedList에 remove(int index) 메서드를 정의하는 코드 일부를 작성한다.
    2. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    3. 실행한 후, 오류 내용을 교정한다. 
    4. App.main() 메서드에 remove(int index) 메서드를 호출하는 코드 일부를 작성한다.
    5. AI가 제안하는 코드를 검토하고, Tab을 눌러 승인한다.
    ```

### 1.2.2 프롬프트 기반 코드/파일 생성 (Prompt-driven Code Generation)
- 자연어 명령(프롬프트)에 따라 함수, 클래스, 혹은 새로운 파일 단위까지 생성
- 요청한 기능 중심의 코드 생성에 해당
- 장점: 프로토타입, 학습용 샘플 코드에 매우 유용
- 한계: 코드 품질·보안 보장 안됨
- 도구: ChatGPT, Claude, Replit AI
- 예
    - “React 로그인 폼 만들어줘” → 전체 함수/클래스/파일 수준 코드 생성
    - "이 코드를 설명해줘" → 코드 동작 원리 및 구조 설명

### 실습 | 직원 관리 CLI 프로그램 만들기
- LinkedList 클래스 작성
    ```
    [프롬프트] 
    링크드 리스트 자료구조를 구현하는 LinkedList 자바 클래스를 작성해줘.
    [개발자]
    LinkedList.java 파일을 생성 후, 복사/붙여넣기 한다.
    ```
- Employee 클래스 작성
    ```
    [프롬프트]
    직원 데이터를 저장할 Employee 클래스를 작성해줘. (이름, 이메일, 생년월일, 부서, 직위)
    [개발자]
    Employee.java 파일을 생성 후, 복사/붙여넣기 한다.
    ```
- App 클래스 변경
    ```
    [프롬프트]
    지금 만든 Employee 클래스를 활용하여 임의의 직원 정보를 10개 추가하고, 목록에 추가된 직원 정보를 출력하는 간단한 일을 하는 App 클래스를 만들어줘.
    [개발자]
    생성된 코드를 App.java에 복사/붙여넣기 한다.
    ```
    ```
    [프롬프트]
    CLI 모드에서 3명의 직원 정보를 입력 받고, 입력 받은 3명의 직원 정보를 목록으로 출력하는 코드로 App 클래스의 main() 메서드를 변경해줘.
    [개발자]
    생성된 코드를 App.java에 복사/붙여넣기 한다.
    ```
    ```
    [프롬프트]
    프로그램을 시작할 때 메뉴를 먼저 출력하고, 사용자가 직원 추가 메뉴를 선택했을 때 한 명의 직원 정보를 입력 받는 것으로 App 클래스를 변경해줘.
    [개발자]
    생성된 코드를 App.java에 복사/붙여넣기 한다.
    ```
    ```
    [프롬프트]
    목록을 출력할 때 직원의 이름, 부서, 직위를 한 줄로 출력하도록, App 클래스의 displayEmployeeList() 메서드를 변경해줘.
    [개발자]
    생성된 코드를 App.java에 복사/붙여넣기 한다.
    ```

## 1.2.3 프로젝트 맥락 이해 기반 코딩 (Context-aware Project Coding)
- 단순 프롬프트 입력이 아니라, IDE와 통합되어 전체 프로젝트 맥락(폴더, 종속성, 기존 코드)을 이해
- 프로젝트 단위의 AI 협업 단계로 진화
- 도구: Cursor IDE, Claude Code CLI, Devin(자율 AI 개발자), Replit Agent
- 예
    - “이 프로젝트에 필요한 모든 종속성을 설치해줘” → 관련 파일을 찾아 의존성 관련 코드를 추가하거나 패키지를 설치
    - “이 코드의 테스트 케이스를 작성해줘” → 단위 테스트 파일 생성
    - “이 파일을 리팩토링 해줘” → 코드 구조 개선 및 최적화

### 실습 | 직원 관리 웹 애플리케이션 만들기
- 프로젝트 준비
    ```
    [프롬프트] 
    직원 관리 웹 애플리케이션 프로젝트를 생성해줘.
    1. 애플리케이션 아키텍처
    - Next.js 기반 React 
    - Language: JavaScript
    - Route 방식: App Router
    - CSS: Tailwind CSS
    - 데이터 저장: In-memory
    2. 주요 기능
    - 직원 목록 보기
    - 직원 추가
    - 직원 정보 수정
    - 직원 삭제
    3. 직원 데이터 필드
    - 이름
    - 이메일
    - 생년월일(YYYY-MM-DD)
    - 부서
    - 직위
    - 입사일(YYYY-MM-DD)
    - 연봉
    ```
    ```
    [개발자]
    - Keep all 선택
    - npm install (노드 패키지를 설치하지 않았다면, 이 명령으로 패키지 설치)
    - npm run dev (서버를 실행하지 않았다면, next.js 서버를 실행함)
    - http://localhost:3000 접속 후 기능 테스트
    ```
- In-memory 대신에 로컬 DB 사용
    ```
    [프롬프트]
    In-memory 데이터베이스 대신에 로컬 DB를 사용하도록 변경해줘.
    1. SQLite 데이터베이스 사용
    2. Prisma ORM 사용
    ```
    ```
    [개발자]
    - Keep all 선택
    - 기존 서버 종료(CTRL + C)
    - npm install (노드 패키지를 설치하지 않았다면, 이 명령으로 패키지 설치)
    - npm run dev (서버를 실행하지 않았다면, next.js 서버를 실행함)
    - http://localhost:3000 접속 후 기능 테스트
    ```
- 목록 페이지 변경
    ```
    [프롬프트]
    직원 목록을 출력할 때 '이름', '부서', '직위', '입사일', '작업' 항목만 표시해줘.
    ```
    ```
    [개발자]
    - Keep all 선택
    - 기존 서버 종료(CTRL + C)
    - npm install (노드 패키지를 설치하지 않았다면, 이 명령으로 패키지 설치)
    - npm run dev (서버를 실행하지 않았다면, next.js 서버를 실행함)
    - http://localhost:3000 접속 후 기능 테스트
    ```
- 상세 페이지 추가
    ```
    [프롬프트]
    직원 목록에서 특정 직원의 이름을 클릭하면 해당 직원의 상세 정보를 출력하는 페이지를 만들어줘.
    ```
    ```
    [개발자]
    - Keep all 선택
    - 기존 서버 종료(CTRL + C)
    - npm install (노드 패키지를 설치하지 않았다면, 이 명령으로 패키지 설치)
    - npm run dev (서버를 실행하지 않았다면, next.js 서버를 실행함)
    - http://localhost:3000 접속 후 기능 테스트
    ```

## 1.4 유형 별 대표 AI 도구와 특징
- GitHub Copilot: 코드 자동 완성 및 제안
    - 특징
        - OpenAI Codex 기반: GPT 모델을 코딩에 특화시킨 버전
        - IDE 통합: VS Code, JetBrains IDE 등에 직접 통합
        - 실시간 제안: 타이핑하면서 즉시 코드 완성 제안
        - 컨텍스트 인식: 현재 파일과 프로젝트 구조 이해
    - 장점
        - 높은 정확도: 가장 많은 학습 데이터와 사용자 피드백
        - 광범위한 언어 지원: 대부분의 프로그래밍 언어 지원
        - 기업용 버전: GitHub Copilot for Business 제공
    - 단점
        - 유료 서비스: 개인 $10/월, 기업 $19/월
        - 인터넷 연결 필요: 오프라인에서 작동 안 함
        - 코드 저작권 논란: 오픈소스 코드 학습 관련 이슈
- ChatGPT: 대화형 AI로 코드 설명, 디버깅, 알고리즘 구현에 활용
    - 특징
        - 대화형 인터페이스: 자연어로 복잡한 요구사항 전달
        - 전체 프로젝트 이해: 큰 컨텍스트 윈도우로 전체 코드베이스 파악
        - 설명과 교육: 코드 작성뿐만 아니라 원리 설명
        - 다양한 작업: 코딩, 디버깅, 리뷰, 문서화 모두 가능
    - 장점
        - 복잡한 로직: 여러 파일에 걸친 복잡한 기능 구현
        - 학습 도구: 코드 설명과 베스트 프랙티스 제공
        - 다국어 지원: 한국어로도 자연스럽게 소통
    - 단점
        - 별도 인터페이스: IDE와 분리된 웹 인터페이스
        - 복사/붙여넣기: 코드를 직접 복사해서 붙여넣어야 함
        - 컨텍스트 제한: 프로젝트 전체를 한 번에 보기 어려움
- Replit AI (Ghostwriter): AI 기반의 협업 코딩 환경 제공
    - 특징
        - 웹 기반 IDE 통합: 브라우저에서 바로 코딩 + AI 활용
        - 실시간 협업: 팀원과 실시간으로 AI와 함께 작업
        - 즉시 실행: 코드 작성 즉시 실행 및 테스트
        - 배포 통합: 작성한 코드 바로 배포 가능
    - 장점
        - 올인원 환경: 개발, AI, 실행, 배포가 한 곳에
        - 초보자 친화적: 설치나 설정 없이 바로 시작
        - 교육용 최적: 학습과 실험에 매우 적합
        - 무료 제공: 기본 기능 무료 사용 가능
    - 단점
        - 웹 기반 제한: 로컬 개발 환경보다 느릴 수 있음
        - 대규모 프로젝트 부적합: 복잡한 엔터프라이즈 프로젝트에는 제한적
        - 인터넷 의존: 항상 온라인 상태 필요
- Cursor IDE: AI 우선으로 설계된 코드 에디터, GPT-4 통합
    - 특징
        - AI 네이티브 에디터: 처음부터 AI 협업을 염두에 두고 설계
        - 멀티모델 지원: GPT-4, Claude, 로컬 모델 등 다양한 AI 모델 선택 가능
        - Composer 기능: 여러 파일을 동시에 편집하는 AI 기능
        - VS Code 호환: VS Code 익스텐션과 설정 그대로 사용
        - Cmd+K (빠른 편집), Cmd+L (채팅 모드)
    - 장점
        - 최신 AI 통합: 가장 최신 AI 모델들 지원
        - 워크플로우 최적화: AI와의 협업에 특화된 UX
        - 빠른 반복: 수정 요청과 적용이 매우 빠름
        - 무료 시작: 기본 기능 무료 제공
    - 단점
        - 상대적으로 새로움: 생태계와 플러그인이 VS Code보다 제한적
        - 학습 곡선: AI 기능을 효과적으로 사용하려면 학습 필요

## 1.5 AI 코딩의 발전 방향
- 멀티모달 AI
    - 텍스트, 코드, 이미지 등 다양한 입력 형식 지원
    - 사용자 요구에 맞춘 맞춤형 응답 생성
    - 예: "이 Figma 디자인을 React 컴포넌트로 만들어줘"
- 에이전트 기능
    - 사용자의 요구에 따라 자동으로 작업 수행
    - 예: "이 버그를 고쳐줘" → AI가 자동으로 에러 로그 분석, 관련 파일 찾기, 테스트 실행, 수정사항 적용
- 실시간 협업
    - 여러 개발자가 같은 AI와 동시에 작업
    - 팀 컨텍스트를 AI가 이해하고 일관성 유지
